# 数据结构与算法基础

#### 课程内容

**数据结构的基本概念**

**基本的数据结构**

- 线性结构
  -  线性表
  - 栈和队列
  - 串
  - 数组和广义表
- 非线性结构
  - 树
  - 图

**基本的数据处理技术**

- 查找技术
- 排序技术



# 一、绪论

### 1.1 数据结构的研究内容

通常用计算解决一个问题的步骤

- 具体问题抽象为数学模型
  - 分析问题
  - 提取操作对象
  - 找出操作对象之间的关系
  - `用数学语言描述 （就是数据结构）`
- 设计算法
- 编程、调试、运行

例子：

> 早期计算机主要用于数值计算，它们的数学模型都是一些数学方程，数据元素间的关系简单，计算复杂
>
> 随着计算机的发展，计算机被越来越多地用于非数值计算

**图书管理系统**

- 操作对象：若干条数据记录
- 操作算法：查询、插入、修改、删除等
- 操作对象之间的关系：线性关系
- 数据结构：`线性数据结构、线性表`

**文件系统的系统结构图**

磁盘根目录下有很多子目录及文件，每个子目录又可以包含多个子目录，但每个子目录只有一个父目录。这是一个树型结构问题，数据与数据成一对多的关系，是一种典型的非线性关系结构——`树型结构`

**地理信息处理**

 问题：找到图中两点之间的最短路径或最经济路径

操作对象：各地点及路的信息

计算机算法：设置信号灯，求出各个可同时通行的路的集合

对象之间的关系：`非线性关系、网状结构——图`



**总结**

- 这些问题的共性是都无法用数学的公式或方程来描述的，是一些`”非数值计算“`的程序设计问题

- 描述非数值计算问题的数学模型不是数学方程，而是如`表`、`树`和`图`之类的具有`逻辑关系`的数据

- 数据结构是一门研究`非数值计算`的程序设计中计算机的`操作对象`以及它们之间的`关系`和`操作`的学科

![image-20220314223543468](C:\Users\Zhongbf\AppData\Roaming\Typora\typora-user-images\image-20220314223543468.png)



![image-20220314223750097](C:\Users\Zhongbf\AppData\Roaming\Typora\typora-user-images\image-20220314223750097.png)

### 1.2 基本概念和术语

#### 1.2.1 数据、数据元素、数据项、数据对象

**数据（Data）**

- `数据`是能输入计算机且能被计算机处理地各种符号地集合、是信息的载体、是对客观事物符号化的表示、能够被计算机识别、存储、加工

- 包括：

  - 数值型数据：整数、实数等
  - 非数值型数据：文字、图像、图形、声音、视频等

**数据元素（Data Element）和 数据项（Data item）**

- `数据元素`是数据的基本单位，在计算机程序中通常作为一个整体进行考虑和处理，也称元素，或称为记录、结点、顶点，一个数据元素可由若干个数据项组成（Data item）
- `数据项`是构成元素不可分割的最小单位
- 数据、数据元素、数据项三者之间的关系：数据 > 数据元素 > 数据项（如：学生表 > 一条记录 > 学号、姓名）

![image-20220313235611538](C:\Users\Zhongbf\AppData\Roaming\Typora\typora-user-images\image-20220313235611538.png)



**数据对象（Data Object）**

`数据对象`是性质相同的数据元素的集合

- 整数数据对象是：集合N={0,1,2......}
- 学生表也可看作一个数据对象

数据元素与数据对象和数据关系

- 数据元素——组成数据基本单位，与数据的关系：是集合的个体

- 数据对象——性质相同的数据元素的集合，与数据的关系是：集合的子集

 

#### 1.2.2 数据结构（Data Structure）

> **数据结构的定义**
>
> 数据元素不是孤立存在的，它们之间存在着某种关系，数据元素相互之间的关系成为`结构`（逻辑结构）
>
> 数据结构是指相互之间存在一种或多种特定关系的数据元素集合；或者说，数据结构是带结构的数据元素的集合

数据结构包含下面三个方面的内容：

- 数据元素之间的逻辑关系，也称为`逻辑结构`。
- 数据元素及其关系在计算机内存中的表示（又称为映像），称为数据的`物理结构`或数据的`存储结构`
- 数据的运算和实现，即对数据元素可以可以施加的操作以及这些操作在相应的存储结构上的实现



**数据结构的两个层次**

1. `逻辑结构`：描述数据元素之间的关系；与数据存储无关；独立于计算机；是从具体问题抽象出来的数学模型

2. `物理结构（存储结构）`：数据元素及其关系在计算机存储器中的结构；是数据结构在计算机中的表示

逻辑结构和物理结构的关系：

- 存储结构是元素本身及其逻辑关系的映像
- 逻辑结构是数据结构的抽象，存储结构是数据结构的实现
- 两者综合起来建立了数据元素之间的结构关系



**逻辑结构的种类**

划分方法一（线性结构和非线性结构）

- 线性结构：有且仅有一个开始和一个终端结点，并且所有的结点都最多只有一个直接前趋和一个直接后继（如：线性表、栈、队列、串）

- 非线性结构：一个结点可能有多个直接前趋和直接后继。如树、图

划分方法二（四类基本逻辑结构）

1. 集合：数据结构中的元素之间除了“同属一个集合” 的相互关系外，别无其他关系
2. 线性结构：数据结构中的元素存在一对一的相互关系；
3. 树形结构：数据结构中的元素存在一对多的相互关系；
4. 图形结构：数据结构中的元素存在多对多的相互关系。



**存储结构的种类**

> 四种基本存储结构：顺序存储结构、链式存储结构、索引存储结构、散列存储结构

`顺序存储结构`

- 用一组连续的存储单元依次存储数据元素，数据元素之间的逻辑关系由元素的存储位置来表示
- C语言用数组来实现顺序存储结构

`链式存储结构`：

- 用一组任意的存储单元存储数据元素，数据元素之间的逻辑关系用指针（地址）来表示
- C语言中用指针来实现链式存储结构

`索引存储结构`

- 在存储节点信息的同时，还建立附加的索引表。索引表中的每一项称为一个索引项
- 索引项的一般形式：（关键字,地址）；关键字是能唯一标记一个节点的哪些数据项

`散列存储结构`

- 根据结点的关键字直接计算出该结点的存储地址



#### 1.2.3 数据类型和抽象数据类型

> 在使用高级程序设计语言编写程序时，必须对程序出现的每个变量、常量或表达式，明确说明它们所属的数据类型。（如C语言中：提供int，char，float，double等基本数据类型；数组、结构等构造数据类型）
>
> 一些最基本数据结构可以用数据类型来实现，如数组、字符串等
>
> 而另一些常用的数据结构，如栈、队列、树、图等，不能直接用数据类型来表示
>
> 数据类型的作用
>
> - 约束变量或常量的取值范围
> - 约束变量或常量的操作

**数据类型（Data Type）**

定义

数据类型时一组性质相同的值的集合以及定义于这个值集合上的一组操作的总称。

数据类型=值的集合+值集合上的一组操作         

**抽象数据类型（Abstract Data Type）**

是指一个数学模型以及在此数学模型上的一组操作，由用户定义，从问题抽象出数据模型（逻辑结构）；还包括定义在数据模型上的一组抽象运算（相关操作），不考虑计算机内的具体存储结构与运算的具体实现算法



抽象数据类型的形式定义

抽象数据类型可用（D，S，P）三元组表示，其中D是数据对象；S是D上的关系集；P是对D的基本操作集

```
ADT 抽象数据类型名{
	数据对象:<数据对象的定义>
	数据关系:<数据关系的定义>
	基本操作:<基本操作的定义> 
} ADT 抽象数据类型名
其中数据对象、数据关系的定义用伪代码描述
基本操作的定义格式为：
	基本操作名（参数表），
	初始条件:<初始条件描述>,
	操作结果:<操作结果描述>
ADT Circle{
	数据对象:D={r,x,y|r,X,y均为实数}
	数据关系:R={<r,x,y>|r是半径,<x,y>是圆心坐标}
	基本操作:
	Circle(&C,r,x,y)
		操作结果:构造一个圆
	double Area(C)
		初始条件：圆已存在
		操作结果：计算面积
	.......
	
}ADT Circle
```



#### 1.3 抽象数据类型的表示与实现

> 一个问题抽象为一个抽象数据类型后，仅是形式上的抽象定义，还没有达到问题解决的目的，要实现这个目标，就要把抽象的变成具体的，即抽象数据类型在计算机实现，变为一个能用的具体的数据类型
>
> ​	用C语言实现抽象数据类型
>
> - 用已有数据类型定义描述它的存储结构
> - 用函数定义描述它的操作

抽象数据类型如何实现？

- 抽象数据类型可以通过固有的数据类型（如整型、实型、字符型等）来表示



#### 1.4 算法和算法分析

###### 1.4.1 算法

> 算法的定义：对特定问题求解方法和步骤的一种描述，它是指令的有限序列。其中每个指令表示一个或多个操作，算法就是解决问题的方法和步骤

**算法的描述**

- 自然语言：英文、中文
- 流程图：传统流程图、NS流程图
- 伪代码：类语言（类C语言）
- 程序代码：C语言程序、Java语言程序

**算法与程序**

- `算法`是解决问题的一种方法或一个过程，考虑如何将输入转换成输出，一个问题可以有多种算法
- `程序`是用某种程序设计语言对算法的具体实现

**算法特性**(一个算法必须具备以下五个重要特性)

- 有穷性：一个算法必须总是在执行有穷步之后结束，且每一步都在有穷时间内完成。
- 确定性：算法中的每一条指令必须有确切的含义，没有二义性，在任何条件下，只有唯一的一条执行路径，即对于相同的输入只能得到相同的输出
- 可行性：算法是可执行的，算法描述的操作可以通过已经实现的基本操作执行有限次来实现
- 输入：一个算法有零个或多个输入
- 输出：一个算法有一个或多个输出

**设计算法的要求**

- 正确性（Correctness）：算法满足问题要求，能正确解决问题（转化成程序后对于典型、苛刻的输入数据能得到想要的结果）
- 可读性（Readability）：算法主要是为了人的阅读和交流，其次才是为计算机执行，因此算法应该易与人的理解
- 健壮性（Robustness）：指当输入非法数据时，算法恰当的做出反应或进行相当处理，而不是产生莫名其妙的结果。处理出错的方法，不应该是中断程序的执行，而是要返回表示错误的值
- 高效性（Efficiency）：要求花费尽量少的时间和尽量低的存储需求



###### 1.4.2 算法分析

> 通过算法的效率判断一个算法的优劣，算法效率通过下面两个方面来考虑
>
> - 时间效率：指的是算法所耗费的时间
>
> - 空间效率：指的是算法执行过程中所耗费的存储空间
>
>   时间效率和空间效率有时候是矛盾的

**算法时间效率的度量**

算法时间效率可以用依据该算法编制的程序在计算机上执行所消耗的时间来度量，用下面两种方法

- 事后统计：将算法实现，测算其时间和空间开销，缺点是编写程序实现算法将花费较多的时间和精力；所得实验结果依赖于计算机的软硬件等环境因素，掩盖算法本身的游龙
- 事前分析：对算法所消耗资源的一种估算方法
  - 方法：算法运行时间=Σ每条语句频度×该语句执行一次所需的时间（单位时间）
  - 算法的时间复杂度：

**时间复杂度**

算法所需执行时间的度量：T(n)=O(f(n))

 分析算法时间复杂度

1. 找出语句频度最大的那条语句作为基本语句（嵌套最深层的语句）
2. 计算基本语句的频度得到问题规模n的某个函数
3. 取其数量级用符号”O“表示

**空间复杂度**

算法所需存储空间的度量：S(n)=O(f(n))



数据结构思维导图：

![image-20220314223121142](C:\Users\Zhongbf\AppData\Roaming\Typora\typora-user-images\image-20220314223121142.png)





# 二、线性表

### 2.1 线性表的定义和特点

**线性表的定义**

> 线性表是具有相同特性的数据元素的一个有限序列**（a~1~,a~2~...a~i+1~,a~i~,a~i+1~,...a~n~）**

第一个数据元素叫做`起始结点`（a~1~）；最后一个数据元素叫做`终端结点`（a~n~）;

每个数据元素的前面一个数据元素叫做`直接前趋`，后面的叫做`直接后继`

`下标`是元素的序号，表示元素在表中的位置，n是元素的总个数，即表长，n=0时称为`空表`

**线性表的逻辑特征**

在非空的线性表，有且仅有一个开始结点a~1~，他没有直接前趋，而仅有一个直接后继；有且仅有一个终端结点a~n~，他没有直接后继，而仅有一个直接前趋；其余的内部结点都有有且仅有一个直接前趋和一个直接后继



### 2.2 案例引入

案例一：一元多项式的运算

案例二：图书信息管理系统

总结：

线性表中数据元素的类型可以为简单类型，也可以为复杂类型

许多实际应用问题所涉及的基本操作有很大相似性，不应为每个具体应用独编写一个程序

从具体应用中抽象出共性的逻辑结构和基本操作（抽象数据类型），然后实现其存储结构和基本操作



### 2.3 线性表的类型定义

抽象数据类型线性表:

ADT List{	
	数据对象：D={ a~i~|a~i~属于Elemset,（i=1,2,...,n,n≥0}

​	数据关系：R={<a~i-1~,a~i~>a~i-1~,a~i~属于D，（i=2,3,...,n）|}

​	基本操作：

​		InitList(&L);	DestroyList(&L);

​		ListInsert(&L,i,e); 	ListDelete(&L,i,&e)

​		.......

} ADT List



### 2.4 线性表的顺序表示和实现

> 在计算机内，线性表有两种基本的存储结构：
>
> 顺序存储结构和链式存储结构

###### 2.4.1 线性表的顺序存储表示

线性表的顺序表示又称为顺序存储结构或顺序映像

**顺序存储定义**

- 把逻辑上相邻的数据元素存储在物理上相邻的存储单元中的存储结构
- 线性表顺序存储结构占用一片`连续`的存储空间。知道某个元素的存储位置就可以计算其他元素的存储位置

**顺序表中元素存储位置的计算**

LOC(a~i~) = LOC(a~1~)  + (i-1) × L

LOC(a~1~) 是第一个数据元素的存储位置（基地址）；L是元素占用的存储单元

**顺序表的优缺点**：

- 优点：
  - 存储密度大（节点本身所占存储量/结点结构所占的存储量）
  - 可以随机存取表中任一元素（随机存储法）
- 缺点：
  - 在插入、删除某一元素时，需要移动大量元素
  - 浪费存储空间
  - 属于静态存储形式，数据元素的个数不能自由扩充



###### 2.4.1 线性表的顺序存储实现



### 2.5  线性表的链式表示和实现

> 链式存储结构：结点在存储器中的位置是任意的，即逻辑上相邻的数据元素在物理上不一定相邻；线性表的链式表示又称为非顺序映像或链式映像

- 用一组物理位置任意的存储单元来存放线性表的数据元素

- 这组存储单元既可以是连续的，也可以是不连续的，甚至是零散分布在内存的任意位置上。

- 链表中元素的逻辑次序和物理次序不一定相同

**与链式存储有关的术语**

- 结点：数据元素的存储映像；由数据域和指针域两部分组成（指针域存储下一个结点的地址）

- 链表：n个节点由指针域组成一个链表；他是线性表的链式存储映像，称为线性表的链式存储结构

 单链表、双链表、循环链表

- 单链表：结点只有一个指针域的链表，称为单链表或线性链表
- 双链表：结点有两个指针域的链表，称为双链表
- 首尾相接的链表称为循环链表

头指针、头节点和首元结点

- 头指针：是指向链表中第一个节点的指针
- 首元结点：是指链表中存储第一个数据元素a~1~的结点
- 头节点：是在链表的首元结点之前附近的一个节点（设置头节点的好处，便于首元结点的处理、便于空表和非空表的统一处理）

**链表（链式存储结构）的特点**

结点在存储器中的位置是任意的，即逻辑上相邻的数据元素在物理上不一定相邻

访问时只能通过头指针进入链表，并通过每个结点的指针域依次向后顺序扫描其余节点，所以寻找第一个结点和最后一个节点所花费的时间不等（顺序存取法）

**链式存储结构的优缺点**

- 优点
  - 节点空间可以动态申请和释放
  - 数据元素的逻辑次序靠结点的指针来指示，插入和删除时不需要移动数据元素

- 缺点
  - 存储密度小，每个结点的指针域需要额外占用存储空间。
  - 链式存储结构时非随机存取街斗。对任一节点的操作都要从头指针依指针链找到该节点，这增加了算法的复杂度

### 2.6 顺序表和链表的比较

![image-20220315111331312](C:\Users\Zhongbf\AppData\Roaming\Typora\typora-user-images\image-20220315111331312.png)

### 2.7 线性表的应用

无序表合并和有序表合并

### 2.8 案例分析与实现

多项式运算



# 三、栈和队列

### 3.1 栈和队列的定义和特点

###### 3..1.1 栈的定义和特点

> 栈（stack）是一个特殊的线性表，是限定仅在一端（通常是表尾）进行插入和删除操作的线性表
>
> 又称为后进先出（Last In First Out）的线性表，简称LIFO结构

**栈的相关概念**

- 栈是仅在表尾进行插入、删除操作的线性表，表尾称为`栈顶`（Top）；表头称为`栈底`（Base）
- 插入元素到栈顶（表尾）的操作称为`入栈`（PUSH），从栈顶（表尾）删除最后一个元素的操作，称为`出栈`（POP）
- 逻辑结构：同线性表相同，仍为一对一关系
- 存储机构：用顺序栈或链栈存储均可，但以顺序栈更为常见
- 运算规则：只能在栈顶运算，且访问结点时依照后进先出（LIFO）的原则



###### 3..1.2 队列的定义和特定

> 队列（queue）是一种先进先出（Frist In Frist Out——FIFO）的线性表
>
> 在表一端插入（表尾），在另一端（表头）删除

**队列的相关概念**

- 定义：只能在表的一端进行进行插入运算，在表的另一端进行删除运算的线性表（头删尾插）
- 逻辑结构：与同线性表相同，仍为一对一关系
- 存储结构：顺序队或链队，以循环顺序队列更常见
- 运算规则：只能在队首和队尾运算，且访问结点时依照先进先出（FIFO）的原则
- 实现方式：关键是掌握入队和出队操作，具体实现依顺序队或链队的不同而不同

### 3.2 案例引入

进制转换（十进制转八进制）

括号匹配的检验

表达式求值

舞伴问题（队列）

### 3.3 栈的表示和操作的实现

###### 3.3.1 栈的抽象数据类型的类型定义

```
ADT Stack{
	数据对象
	数据关系
	基本操作
}
```



### 3.4 栈与递归

> 递归的定义
>
> - 若一个对象部分的包含它自己，或用它自己给自己定义，则称这个对象时递归的；
> - 若一个过程直接或间接地调用自己，则称这个过程时递归地过程

以下三种情况常常用到递归方法

1. 递归定义地数学函数：阶乘函数
2. 具有递归特性的数据结构：二叉树、广义表
3. 可递归求解的问题：迷宫问题



**递归问题——用分治法求解**

> 分治法：对于一个较为复杂的问题，能够分解成几个相对简单的且解法相同或类似的子问题来求解

必备的三个条件

1. 能将一个问题转变成一个新问题，而新问题与原问题的解题相同或者类同。不同的仅是处理的对象，且这些对象的变化时有规律的
2. 可以通过上述转化而是问题简化
3. 必须有一个明确的递归出口，或称递归的边界

分治法求解递归问题算法的一般形式

```c
void p(参数表){
	if (递归结束条件) 可直接求解步骤;  ------基本项
    else p(较小的参数); ------归纳项
}
例如：
 long Fact(long n){
    if(n == 0) return 1;	------基本项
    else return n* Fact(n-1); ------归纳项
}
```

函数的循环嵌套——最后调用先返回（后进先出）；符合栈的特点

递归的优缺点：

优点：结构清晰

缺点：每次调用要生成工作记录，保存状态信息，入栈；返回时要出栈，恢复状态信息，时间开销大



递归程序在执行时需要系统提供栈来实现

仿照递归算法执行过程中递归工作栈的状态变化可写出相应的非递归程序

改写后的非递归算法与原来的递归算法相比，结构不够清晰，可读性较差，有的还需要经过一系列的优化



### 3.5 队列的表示和实现

3.5.3 队列的抽象数据类型定义

```
ADT Stack{
	数据对象
	数据关系
	基本操作
}
```



# 四、串、数组和广义表

### 4.1 串

> 串（string）——零个或多个任意字符组成的有限序列

**串——术语**

- 字串：一个串中任意个连续字符组成的子序列称为该串的`字串`
- 主串：包含字串的串相应地称为`主串`
- 字符位置：字符在`序列中的序号`为该字符在串中的位置
- 字串位置：字串第一个字符在主串中的位置
- 空格串：由一个或多个空格组成的串，与空串不同
- 串相等：当且仅当两个串的长度相等并且各个对应位置上的字符都相同时，这两个串才是相等的

- 所有的空串都是相等的

### 4.2 案例引入

串的应用非常广泛，计算机上的非数值处理的对象大部分时字符串数据，例如：文字编辑、符号处理、各种信息处理系统等等；

案例1：病毒感染检测（研究者将人的DNA和病毒DNA均表示成由一些字母组成的字符串序列）



### 4.3 串的类型定义、存储结构及其运算

###### 4.3.1 串的数据类型定义

```
ADT Stack{
	数据对象
	数据关系
	基本操作
}
```

###### 4.3.2 串的存储结构

> 串中元素逻辑关系与线性表的相同，串可以采用与线性表相同的存储结构（顺序和链式）

4.3.3 串的模式匹配算法

算法目的：

确定主串中所含字串（模式串）第一次出现的位置（定位）

算法应用

- 搜索引擎、拼写检查、语言翻译、数据压缩

算法种类

- BF算法（Brute-Force，简单匹配法，枚举法）
- KMP算法（特点：速度快）

### 4.4 数组

> 数组：按一定格式排列起来的具有相同类型的数据元素的集合

一维数组：若线性表中的数据元素为非结构的简单元素，则称为一维数组

一维数组的逻辑结构：线性结构；定长的线性表

生命格式：数据类型	变量名称[长度]



二维数组：若一维数组中的数据元素又是一维数组结构，则称为二维数组

二维数组的逻辑结构

- 非线性结构：每个数据元素即在一个行表中，又在一个列表中
- 线性结构（定长的线性表）：该线性表的每个数据元素也是一个定长的线性表



三维数组：若二维数组的元素又是一个一维数组，则称三维数组

n维数组：若n-1维数组中的元素又是一个一维数组结构，则称作n维数组



**结论**

线性表结构式数组结构的一个特例；而数组结构又是线性表结构的扩展

**数组特点**

结构固定——定义后，维数和维界不再改变

###### 4.4.1 数组的抽象数据类型定义

```
ADT Stack{
	数据对象
	数据关系
	基本操作
}
```

###### 4.4.2 特殊矩阵的压缩存储

矩阵：一个由m×n个元素排成的m行n列的表

矩阵的常规存储：将矩阵描述为一个二维数组

矩阵的常规存储的特点：可以对其元素进行随机存取；矩阵运算非常简单；存储的密度为1

不适宜常规存储的矩阵：值相同的元素很多且呈某种规律分布；零元素多

矩阵的压缩存储：为多个相同的非零元素只分配一个存储空间；对零元素不分配空间

### 4.5 广义表

广义表中的数据元素有相对次序；一个直接前驱和一个直接后继

广义表的长度定义为最外层所包含元素的个数；如C=(a,(b.c))式长度为2的广义表

广义表的深度定义为该广义表展开后所含括号的重数；如A=(b,c)的深度为1，B=(A,d)的深度为2，

C=(f,B,h)的深度为3，注意原子的深度为0；空表的深度为1

广义表可以为其他广义表共享，如B共享了表A（B=(A)）

广义表可以式一个递归的表；如F=(a,F)=(a,(a,(a,....)))

广义表式多层次结构，广义表的元素可以是单元素，也可以是子表，而子表的元素还可以是子表



**广义表和线性表的区别**

广义表可以看成是线性表的推广，线性表是广义表的特例

广义表的结构相当灵活，在某种前提下，它可以兼容线性表、数组、树和有向图等各种常用的数据结构

当二维数组的每行（或每列）作为子表处理时，二维数组即为一个广义表

另外，数和有向图也可以用广义表来表示。

由于广义表不仅几种了线性表、数组、树和有向图等常见数据结构的特点，而且有效地利用存储空间，因此子啊计算机的许多应用领域都有成功使用广义表的实例



# 五、树和二叉树

### 5.1 树和二叉树的定义

> 树的定义：树（Tree）是n（n≥0）个结点的有限集，若n=0，称为空树；若n＞0则满足如下条件：
>
> 1. 有且仅有一个特定的称为根（Root）的结点；
> 2. 其余结点可分为m（m≥0）个互不相交的有限集T1、T2、T3、......T~m~;其中每一个集合本身又是一棵树，并称为根的子树（SubTree）

###### 5.1.1 树的基本术语

- 结点：数据元素以及指向子树的分支
- 根节点：非空树中无前驱结点的结点
- 结点的度：结点拥有的子树数
- 树的度：树内各结点的度的最大值
- 度=0的结点称为：叶子或终端结点；度≠0的结点称为分支结点或非终端结点；根结点以外的分支结点称为内部节点
- 结点的子树的根称为该结点的孩子，该节点称为孩子的双亲，拥有同一个双亲的结点称为兄弟，同一层次的结点称为堂兄弟，节点的祖先是从根到该节点所经分支上的所有结点。结点的子孙是以某节点为根的子树中的任一结点
- 树的深度：树中结点的最大层次
- 有序树：树中结点的各子树从左至右有次序（最左边的为第一个孩子）
- 无序树：树中结点的各子树无次序
- 森林：是m（m≥0）课互不相交的树的集合

###### 5.1.2 树结构和线性结构的比较

| 线性结构                                   | 树结构                                 |
| ------------------------------------------ | -------------------------------------- |
| 第一个数据元素（无前驱）                   | 根节点（只有一个，没有双亲）           |
| 最后一个数据元素（无后继）                 | 叶子节点（可以有多个）无孩子           |
| 其他数据元素（一个前驱，一个后继，一对一） | 中间节点（一个双亲，多个孩子，一对多） |

###### 5.1.3 二叉树的定义

为何要重点研究每个结点最多只有两个”叉“的树结构？

二叉树的结构最简单，规律性最强；可以证明，所有树都能转为唯一对应的二叉树，不失一般性，

普通树（多叉树）若不转化为二叉树，则运算很难实现

二叉树在树结构的应用中起着非常重要的作用，因为对二叉的许多操作算法简单，而任何树都可以与二叉树相互转换，这样久解决了树的存储结构及其运算中存在的复杂性



**二叉树的定义**

二叉树是n（n≥0）个结点的有限集，它或者是空集（n=0），或者由一个根节点及两颗互不相交的分别称作这个跟的左子树和右子树的二叉树组成

**特点**

1. 每个结点最多有俩孩子（二叉树中不存在度大于2的结点）
2. 子树有左右之分，其次序不能颠倒
3. 二叉树可以是空集合，跟可以有空的左子树或空的右子树

二叉树不是树的特殊情况，它们是两个概念

二叉树的子树要区分左子树和右子树，即使只有一棵子树也要进行区分，说明它是左子树，还是右子树

树当节点只有一个孩子时，就无需区分它是左还是右的次序，因此二者是不同的，这是二叉树与树的最主要的差别



**二叉树的5种基本形态**

- 空二叉树
- 根和空的左右子树
- 根和左子树
- 根和右子树
- 根和左右子树

### 5.2 案例引入

数据压缩问题：将数据文件转换成由0、1组成的二进制串，称之为编码

利用二叉树求解表达式的值

### 5.3 树和二叉树的抽象数据类型定义



### 5.4 二叉树的性质和存储结构

###### 5.4.1 二叉树的性质

性质1：二叉树的第 *i* 层上至多有2^i-1^个结点（*i*≥1）；第i层上至少有1个节点

性质2：深度为 *k* 的二叉树至多有2^k^-1个结点（*k*≥1）；深度为 *k* 时至少有 *k* 个结点

性质3：对任何一颗二叉树*T*，如果其叶子树为n~0~，度为2的节点数n~2~，则n~0~ = n~2~-1



**两种特殊形式的二叉树**

满二叉树

- 一颗深度为 *k* 且有2^k^-1个结点的二叉树称为满二叉树

特点：

- 每一层上的节点数都是最大节点数
- 叶子节点全部在最底层
- 堆满二叉树结点位置进行编号，编号规则：从根节点开始，自上而下，自左而右，每一节点都有元素
- 满二叉树在同样深度的二叉树中节点个数最多
- 满二叉树在同样深度的二叉树中叶子节点个数最多

完全二叉树

- 深度为 *k* 的具有 n 个结点的二叉树，当且仅当其每一个结点都与深度为 *k* 的满二叉树中编号为 1 ~ n 的结点一一对应时，称之为完全二叉树s

![image-20220316223332145](C:\Users\Zhongbf\AppData\Roaming\Typora\typora-user-images\image-20220316223332145.png)

在满二叉树中，从最后一个结点开始，连续去掉任意个结点，即是一颗完全二叉树（一定是连续的去掉）

特点

1. 叶子只可能分布在层次最大的两层上。
2. 对任一结点，如果树的最大层次为 *i* ，则其左子树的最大层次必为 i 或 i + 1

性质4：具有 n 个结点的完全二叉树的深度为[log~2~n] + 1,证明了结点书n与完全二叉树深度 k 之间的关系

性质5：双亲结点编号和孩子编号的关系

###### 5.4.2 二叉树的存储结构

二叉树顺序存储

特点：节点间关系蕴含在其存储位置中

缺点：浪费空间，适于存满二叉树和完全二叉树

二叉树的链式存储结构

二叉链表 lchild data rchild

三叉链表  lchild data parent rchild

### 5.5 遍历二叉树和线索二叉树

###### 5.5.1 遍历二叉树

遍历定义——顺着某一条搜索路径寻访二叉树中的结点，使得每个结点均被访问一次，而且仅被访问一次（又称周游）

- 访问的含义很广，可以是对结点做各种处理，如：输出结点的信息，修改结点的数据值等，但要求这种访问不破坏原来的数据结构

遍历目的——得到树中所有结点的一个线性排列

遍历用途——它是树结构插入、删除、修改、查询和排序运算的前提，是二叉树一切运算的基础和核心



若规定先左后右，则只有三种情况

- 先（根）序遍历
- 中（根）序遍历
- 后（根）序遍历



**线索二叉树**

利用二叉链表中的空指针域：

如果某个结点的左孩子为空，则将空的左孩子指针域改为指向其前驱；如果某结点的右孩子为空，则将空的右孩子指针域改为指向其后继——这种改变指向的指针称为“线索”

加上了线索的二叉树称为线索二叉树 



### 5.6 树和森林

###### 5.6.1 树的存储结构

双亲表示法：定义结构数组，存放树的结点，每个结点含两个域：

- 数据域（存放结点本身信息）|双亲域（指向结点的双亲结点子啊数组中的位置）

- 特点找双亲容易，找孩子难

孩子链表：

- 找孩子容易

孩子兄弟表示法（二叉树表示法，二叉链表表示法）

一个指针域指向孩子，一个指向兄弟



**树与二叉树的转换**

- 将树转换为二叉树进行处理，利用二叉树的算法来实现对数的操作

- 由于树和二叉树都可以用二叉链表作存储结构，则以二叉链表作媒介可以导出树与二叉树之间的对应关系
- 给定一棵树，可以找到唯一的一颗二叉树与之对应

**森林与二叉树的转换**

树变二叉根相连

**树和森林的遍历**

- 先根（次序）遍历
- 后根（次序）遍历
- 按层次遍历



### 5.7 哈夫曼树

哈夫曼树（最优二叉树）

###### 5.7.1 哈夫曼树的基本概念

路径：从树中一个结点到另一个节点之间的分支构成这两个结点的路径

结点的路径长度：两结点间路径上的分支数

树的路径长度：从树根到每一个结点的路径长度之和（记作TL），节点数目相同的二叉树中，完全二叉树是路径长度最短的二叉树

权（weight）：将树中结点赋给一个有着某种含义的数值，则这个数值称为该结点的权

结点的带权路径长度：从根节点到该结点之间的路径长度与该结点的权的乘积

树的带权路径长度：树中所有叶子结点的带权路径长度之和

哈夫曼树：最优树（带权路径长度最短的树）度要相同，所有一般的最优二叉树、最优三叉树

因为构造这种书的算法是由哈夫曼教授与1952年提出的，所以被称为哈夫曼树，相应的算法称为哈夫曼算法

哈夫曼树权越大的叶子离根越近



###### 5.7.2 哈夫曼算法

![image-20220318002006679](C:\Users\Zhongbf\AppData\Roaming\Typora\typora-user-images\image-20220318002006679.png)



###### 5.7.3 哈夫曼编码（Huffman）

在远程通信中，要将待传字符转换成由二进制的字符串：

方法一：定长编码（ASCII）；缺点浪费空间

方法二：若将编码设计为长度不等的二进制编码，既让待传字符串中出现次数较多的字符采用尽可能短的编码，则转换的二进制字符串便可能减少；缺点：重码；

关键：要设计长度不等的编码，则必须使任一字符编码都不是另一个字符的编码的前缀，这种编码称作前缀编码



什么样的前缀编码能使电文总长最短？——哈夫曼编码

1. 统计字符集中每个字符在电文中出现的平均概率（概率越大，要求编码越短）
2. 利用哈夫曼树的特点：权越大的叶子离根越近；将每个字符概率值作为权值，构造哈夫曼树。则概率越大的结点，路径越短
3. 在哈夫曼树的每个分支上标上0或1：结点的左分支标0.右分支标1，把从根到每个叶子的路径上的标号连接起来，作为该叶子代表的字符的编码



两个问题：

为什么哈夫曼编码能够保证使前缀编码？

因为没有一片树叶是另一篇树叶的祖先，所以每个叶结点的编码就不可能是其他叶结点编码的前缀

为什么哈夫曼编码能够保证字符编码总长最短？

因为哈夫曼树的带权路径长度最短，故字符编码的总长最短

- 性质1	哈夫曼编码是前缀码
  - 性质2哈夫曼编码是最有前缀码



# 六、图

### 6.1 图的定义和术语

> 图：G=(V,E)；Graph=(Vertex,Edge)
>
> V：顶点（数据元素）的有穷非空集合；
>
> E：边的有穷集合

无向图：每条边都是无方向的

有向图：每条边都是有方向的

![image-20220318011028105](C:\Users\Zhongbf\AppData\Roaming\Typora\typora-user-images\image-20220318011028105.png)

完全图：任意两个点都有一条边相连

![image-20220318011210417](C:\Users\Zhongbf\AppData\Roaming\Typora\typora-user-images\image-20220318011210417.png)

![image-20220318011446668](C:\Users\Zhongbf\AppData\Roaming\Typora\typora-user-images\image-20220318011446668.png)

![image-20220318011635923](C:\Users\Zhongbf\AppData\Roaming\Typora\typora-user-images\image-20220318011635923.png)

![image-20220318011734576](C:\Users\Zhongbf\AppData\Roaming\Typora\typora-user-images\image-20220318011734576.png)

![image-20220318011939779](C:\Users\Zhongbf\AppData\Roaming\Typora\typora-user-images\image-20220318011939779.png)

![image-20220318012143308](C:\Users\Zhongbf\AppData\Roaming\Typora\typora-user-images\image-20220318012143308.png)

权与网：图中边或弧所具有的相关数称为权。表明从一个顶点到另一个顶点的距离或耗费，带权的图称为网

子图

![image-20220318012521486](C:\Users\Zhongbf\AppData\Roaming\Typora\typora-user-images\image-20220318012521486.png)

### 6.2 案例引入

六度空间理论：你和任何一个陌生人之间所间隔的人不会超过六个人，也就是说，最多通过六个人 你就能够认识一个陌生人

### 6.3 图的数据类型定义



### 6.4 图的存储结构

图的逻辑结构：多对多

存储结构：数组表示法（邻接矩阵）；多重链表（邻接法；邻接多重法、十字链表）

###### 6.4.1 邻接矩阵

![image-20220318014150623](C:\Users\Zhongbf\AppData\Roaming\Typora\typora-user-images\image-20220318014150623.png)

缺点：不便于增删结点，浪费空间（对稀疏图）



###### 6.4.2 邻接表



### 6.5 图的遍历

遍历定义：从已给的连通图中某一项点出发，沿着一些边访遍图中所有的定点，且使每个顶点仅被访问一次，就叫做图的遍历，它是图的基本运算

图常用的遍历：

- 深度优先搜索（Depth_First Search——DFS）
- 广度优先搜索（Breadth_First Search——BFS）



### 6.6 图的应用

最小生成树：给定一个无向网络，在该网的所有生成树中，使得各边权值之和最小的那颗生成树称为该网的最小生成树，也叫最小代价生成树

最短路径

拓扑排序

关键路径



# 七、查找

### 7.1 查找的基本概念

在哪里找——查找表

- 查找表是由同一类型的数据元素（或记录）构成的集合。由于集合中的数据元素之间存在着松散的关系，因此查找表是一种应用灵便的结构

怎么查找——根据给定的某个值，在查找表中确定一个其关键字等于给定值的数据元素或（记录）

- 关键字：用来标记一个数据元素（或记录）的某个数据项的值
  - 主关键字：可唯一的标记一个记录的关键字是主关键字
  - 次关键字：反之，用以识别若干记录的关键字的次关键字

查找成功否？

- 查找表中存在这样一个记录，则称“查找成功”；查找结果给出整个记录的信息，或指示该记录在查找表中的位置

- 否则称“查找不成功”；查找结果给出“空记录”或“空指针”

查找目的是什么？

对查找表经常进行的操作：

- 查询某个“特定的”数据元素是否在查找表中；
- 检索某个“特定的”数据元素的各种属性
- 在查找表中插入一个数据元素
- 删除查找表中的某个数据元素

查找表怎么分类？

查找表可分为两类

- 静态查找表：仅作“查询”（检索）操作的查找表
- 动态查找表：作“插入”和“删除”操作的查找表

如何评价查找算法？

查找算法的评价指标：

- 关键字的平均比较次数，也称平均查找长度（ASL）

查找过程中我们要研究什么？

- 查找的方法取决于查找表的结构，即表中数据元素是依何种关系组织一起的
- 由于对查找表来说，在集合中查询或检索一个“特定的”数据元素是，若无规律可循，只能对集合中的元素一一加以辨认直至找到为止
- 而这样的 “查询” 或 “检索” 是任何计算机应用系统中使用频度都很高的操作，因此设法提高查找表的查找效率，是讨论的重点
- 为提高查找效率，一个方法就是在构造查找表时，在集合中的数据元素之间人为的加上某种确定的约束关系

### 7.2 线性表的查找

###### 7.2.1 顺序查找（线性查找）

应用范围：

- 顺序表或线性链表表示的静态查找表
- 表内元素之间无序

顺序查找算法：

- 带哨兵的顺序查找法

提高顺序查找的效率

- 方法1：查找存储记录原则——按查找概率高低存储

- 方法2：概率不知道的时候，在每个记录中设一个访问频度域；按访问频度进行排序

顺序查找的特点

- 优点：算法简单，逻辑次序无要求，且不同存储结构均适用
- 缺点：ASL太长，时间效率太低

###### 7.2.2 折半查找（二分或对分查找）

折半查找：每次将待查记录所在区间缩小一半

优点：效率比顺序查找高

缺点：只适用于有序表，且限于顺序存储结构（对线性链表无效）

###### 7.2.3 分块查找（索引顺序查找）

将表分成几块，且表或者有序，或者分块有序

建立“索引表”（每个结点含有最大关键字域和指向本快第一个结点的指针，且按关键字有序）

优点：插入和删除比较容易，无需进行大量移动

缺点：要增加一个索引表的存储空间并初始索引表进行排序运算

适用情况：如果线性表既要快速查找又经常动态变化，则可采用分块查找

|          | 顺序查找         | 折半查找 | 分块查找         |
| -------- | ---------------- | -------- | ---------------- |
| ASL      | 最大             | 最小     | 中间             |
| 表结构   | 有序表、无序表   | 有序表   | 分块有序         |
| 存储结构 | 顺序表、线性链表 | 顺序表   | 顺序表、线性链表 |

### 7.3 树表的查找

当表插入、删除操作频繁时，为维护表的有序性，需要移动表中很多记录。改用动态查找表——几种特殊的树，表结构在查找过程中动态生成

- 二叉排序树
- 平衡二叉树
- B-树
- B+树
- 键树

###### 7.3.1 二叉排序树

> 二叉排序树（Binary Sort Tree）又称为二叉搜索树、二叉查找树

定义：二叉排序树或是空树，或是满足如下性质的二叉树：

- 若其左子树非空，则左子树上所有节点的值均小于根结点的值
- 若其右子树非空，则右子树上所有结点的值均大于等于根结点的值
- 其左右子树本身又各是一颗二叉排序树

二叉排序树的性质

- 中序遍历非空的二叉排序树所得的数据元素序列时一个按关键字排列的递增有序序列

二叉排序树的操作——查找

- 若查找的关键字等于根结点，成功
- 否则，若小于根结点，查其左子树，若大于根结点，查其右子树

二叉排序树的查找分析

- 含有n个结点的二叉排序树的平均查找长度和树的形态有关

- 如何提高形态不均衡的二叉排序树的查找效率？——平衡二叉树

二叉排序树的操作——插入

- 若二叉排序树为空，则插入结点作为根结点插入都空树中

- 否则，继续在其左右子树上查找，知道找到空的左右子树，则插入

二叉排序树的操作——生成

- 从空树出发，经过一系列的查找、插入操作之后’可生成一颗二叉排序树
- 一个无序序列可通过构造二叉排序树二变成一个有序序列，构造树的过程就是对无序序列进行排序的过程
- 插入的结点均为叶子结点，故无需移动其他结点。相当于在有序序列上插入记录而无需移动其他记录

![image-20220318163925413](C:\Users\Zhongbf\AppData\Roaming\Typora\typora-user-images\image-20220318163925413.png)

二叉排序树的操作——删除



###### 7.3.2 平衡二叉树

平衡二叉树的定义（balanced binary tree）

- 又称AVL树（Adelson-Velskii and Landis）
- 一颗平衡二叉树或者是空树，或者是具有下列性质的二叉排序树：
  - 左子树与右子树的高度只差的绝对值小于等于1
  - 左子树和右子树也是平衡二叉排序树

### 7.4 散列表

###### 7.4.1 散列表的基本概念

基本思想：记录的存储位置与关键字之间存在的对应关系——hash函数

优点：查找效率高

缺点：空间效率低



散列表的若干术语

散列方法：选取某个函数，依该函数按关键字计算元素的存储位置，并按此存放；查找时，由同一个函数对给定值k计算地址，将k与地址单元中元素关键码进行比，确定查找是否成功

散列函数：散列方法中使用的转换函数

散列表：按散列方法思想构造的表

冲突：不同的关键码映射到同一个散列地址；key1≠key2，但是H(key1)=H(key2)

同义词：具有相同函数值的多个关键字



使用散列表要解决好两个问题

1. 构造好散列函数：
   - 所选函数尽可能简单，以便提高转换速度
   - 所选函数对关键码计算出的地址，应在散列地址集中均匀分布，以减少空间浪费

2. 制定一个好的解决冲突的方案
   - 查找时，如果从散列函数计算出的地址中查不到关键码，则应当依据解决冲突的规则，有规律地查询其他相关单元



# 八、排序

### 8.1 基本概念和排序方法概述

排序：将一组杂乱无章地数据按一定规律顺次排列起来。即将无序序列排成一个有序序列（由小到大或由大到小）的运算

**排序方法的分类**

- 按存储介质可分为：
  - 内部排序：数据量不大、数据在内存，无需内外存交换数据
  - 外部排序：数据量较大、数据在外存（文件排序）；外部排序时，要将数据分批调入内存来排序，中间结果还要及时放入外存，显然外部排序要复杂得多

- 按比较器个数可分为：
  - 串行排序：单处理机（同一时刻比较一对元素）
  - 并行排序：多处理机（同一时刻比较多对元素）

- 按主要操作可分为：
  - 比较排序：用比较的方法，插入排序、交换排序、选择排序、归并排序
  - 基数排序：不比较元素的大小，仅仅根据元素本身的取值确定其有序位置

- 按辅助空间可分为：
  - 原地排序：辅助空间用量O(1)的排序方法（所占的辅助存储空间与参加排序的数据量大小无关）
  - 非原地排序：辅助空间用量超过O(1)的排序方法

- 按稳定性可分为：
  - 稳定排序：能够使任何数值相等的元素，排序以后相对次序不变
  - 非稳定性排序：不是稳定排序的方法

- 按自然性可分为：
  - 自然排序：输入数据越有序，排序的速度越快的排序方法
  - 非自然排序：不是自然排序的方法



### 8.2 插入排序

> 基本思想：每步将一个待排序的对象，按其关键码大小，插入到前面已经排好序的一组对象的适当位置上，直到对象全部插入为止，即边插入边排序，保证子序列中随时都是排好序的

**插入排序的种类**

1. 顺序法定位插入位置——直接插入排序
2. 二分法定位插入位置——二分插入排序
3. 缩小增量多遍排序——希尔排序



直接插入排序

直接插入排序——采用顺序查找法插入位置

折半插入排序——查找插入位置时采用折半查找法

希尔排序

基本思想：先将整个待排记录序列分割成若干子序列，分别进行直接插入排序，待整个序列中的记录“基本有序”时

，在对全体记录进行一次直接插入排序

特点：

1. 缩小增量
2. 多遍插入排序

### 8.3 交换排序

两两比较，如果发生逆序则交换，直到所有记录都排好序为止

常见的交换排序方法：

- 冒泡排序

- 快速排序



###### 8.3.1 冒泡排序

基于简单的交换思想：每趟不断将记录两两比较，并按“前小后大”规则交换

###### 8.3.2 快速排序

基本思想：

- 任取一个元素（如：第一个）为中心，
- 所有比它小的元素一律前方，比它大的元素一律后放，形成左右两个子表；

- 对各子表重新选择中心元素并依次规则调整
- 直到每个子表的元素只剩一个

### 8.4 选择排序

###### 8.4.1 简单选择排序

基本思想：在待排序的数据中选出最大（小）的元素放在其最终的位置

###### 8.4.2 堆排序

堆的定义：

![image-20220318235431580](C:\Users\Zhongbf\AppData\Roaming\Typora\typora-user-images\image-20220318235431580.png)

堆排序

若在输出堆顶的最小值（最大值）后，使得剩余n-1个元素得序列重新建成一个堆，则得到n个元素得次小值（次大值）……如此反复，便能得到一个有序序列，这个过程称之为堆排序

### 8.5 归并排序

基本思想：将两个或两个以上得有序子序列“归并”为一个有序序列

在内部排序中，通常采用的是2-路归并排序

### 8.6 基数排序

基本思想：分配+收集



各种排序方法得综合比较

![image-20220319000702987](C:\Users\Zhongbf\AppData\Roaming\Typora\typora-user-images\image-20220319000702987.png)
